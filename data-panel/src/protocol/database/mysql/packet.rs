use crate::protocol::database::mysql::constant::{MySQLColumnType, MySQLColumnFlags, MySQLStatusFlag, PROTOCOL_VERSION, SERVER_VERSION, CHARSET, MySQLCapabilityFlag, NUL, SEED, MySQLNewParametersBoundFlag};
use crate::protocol::database::{PacketPayload, DatabasePacket};

use rand::Rng;
use bytes::{BytesMut, Buf, BufMut, Bytes};
use crate::session::{get_session_prepare_stmt_context_parameters_count, set_session_prepare_stmt_context_parameter_types};
use crate::protocol::database::mysql::binary::PrepareParamValue;
use crate::protocol::database::mysql::binary;

const PAYLOAD_LENGTH: u32 = 3;
const SEQUENCE_LENGTH: u32 = 1;

/// Generate random bytes.
///
/// @param length length for generated bytes.
/// @return generated bytes
///
pub fn generate_random_bytes(len: u32, seed: &mut Vec<u8>) -> Vec<u8> {
    let mut random = rand::thread_rng();
    for _i in 0..len {
        seed.push(SEED[random.gen_range(0, SEED.len())]);
    }
    seed.to_vec()
}

pub struct MySQLPacketHeader {
    len: u64,
    sequence_id: u32,
    command_packet_type: u8,
    session_id: u64
}

impl MySQLPacketHeader {
    pub fn new(len: u64, sequence_id: u32, command_packet_type: u8, session_id: u64) -> Self {
        MySQLPacketHeader {
            len,
            sequence_id,
            command_packet_type,
            session_id
        }
    }

    pub fn get_len(&self) -> u64 {
        self.len
    }

    pub fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }

    pub fn get_command_packet_type(&self) -> u8 {
        self.command_packet_type
    }

    pub fn get_session_id(&self) -> u64 {
        self.session_id
    }
}

/**
 * MySQL payload operation for MySQL packet data types.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/describing-packets.html">describing packets</a>
 */

pub struct MySQLPacketPayload {
    bytes_mut: BytesMut,
}

impl MySQLPacketPayload {
    pub fn new() -> Self {
        MySQLPacketPayload {
            bytes_mut: BytesMut::new()
        }
    }

    pub fn new_with_payload(bytes_mut: BytesMut) -> Self {
        MySQLPacketPayload {
            bytes_mut: bytes_mut
        }
    }

    pub fn put_u8(&mut self, val: u8) {
        self.bytes_mut.put_u8(val);
    }

    pub fn put_u16_le(&mut self, val: u16) {
        self.bytes_mut.put_u16_le(val);
    }

    pub fn put_u32_le(&mut self, val: u32) {
        self.bytes_mut.put_u32_le(val);
    }

    pub fn put_i32_le(&mut self, val: i32) {
        self.bytes_mut.put_i32_le(val);
    }

    pub fn put_u64_le(&mut self, val: u64) {
        self.bytes_mut.put_u64_le(val);
    }

    pub fn put_i64_le(&mut self, val: i64) {
        self.bytes_mut.put_i64_le(val);
    }

    pub fn put_f64_le(&mut self, val: f64) {
        self.bytes_mut.put_f64_le(val);
    }

    pub fn put_slice(&mut self, val: &[u8]) {
        self.bytes_mut.put_slice(val);
    }

    pub fn put_string_with_nul(&mut self, val: &[u8]) {
        self.bytes_mut.put_slice(val);
        self.bytes_mut.put_u8(NUL);
    }

    pub fn get_uint_le(&mut self, n: usize) -> u64 {
        self.bytes_mut.get_uint_le(n)
    }

    pub fn get_int_le(&mut self, n: usize) -> i64 {
        self.bytes_mut.get_int_le(n)
    }

    pub fn get_f32_le(&mut self) -> f32 {
        self.bytes_mut.get_f32_le()
    }

    pub fn get_f64_le(&mut self) -> f64 {
        self.bytes_mut.get_f64_le()
    }

    pub fn get_uint(&mut self, n: usize) -> u64 {
        self.bytes_mut.get_uint(n)
    }

    pub fn get_int(&mut self, n: usize) -> i64 {
        self.bytes_mut.get_int(n)
    }

    pub fn advance(&mut self, n: usize) {
        self.bytes_mut.advance(n);
    }

    // string with nul
    pub fn get_string_nul(&mut self) -> String {
        let pos = match self.bytes_mut.bytes().iter().position(|&x| x == 0) {
            Some(pos) => pos,
            None => 0 // TODO
        };
        if pos == 0 {
            "".to_string()
        } else {
            let bytes = self.bytes_mut.split_to(pos);
            let result = String::from_utf8_lossy(bytes.bytes()).to_string();
            self.bytes_mut.advance(1);
            result
        }
    }

    /**
     * Write lenenc integer to byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::LengthEncodedInteger">LengthEncodedInteger</a>
     *
     * @param value lenenc integer
     */
    pub fn put_int_lenenc(&mut self, v: usize) {
        if v < 0xfb {
            self.bytes_mut.put_u8(v as u8);
        } else if v < 0x10000 {
            self.bytes_mut.put_u8(0xfc);
            self.bytes_mut.put_u16_le(v as u16);
        } else if v < 0x1000000 {
            self.bytes_mut.put_u8(0xfd);
            self.bytes_mut.put_uint_le(v as u64, 3);
        } else {
            self.bytes_mut.put_u8(0xfe);
            self.bytes_mut.put_u64_le(v as u64);
        }
    }

    /**
     * Read lenenc integer from byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/integer.html#packet-Protocol::LengthEncodedInteger">LengthEncodedInteger</a>
     *
     * @return lenenc integer
     */
    pub fn get_int_lenenc(&mut self) -> u64 {
        let first_byte = self.bytes_mut.get_uint(1) & 0xff;
        if first_byte < 0xfb {
            first_byte
        } else if 0xfb == first_byte {
            0
        } else if 0xfc == first_byte {
            self.bytes_mut.get_uint_le(2)
        } else if 0xfd == first_byte {
            self.bytes_mut.get_uint_le(3)
        } else {
            self.bytes_mut.get_uint_le(8)
        }
    }

    /**
     * Write lenenc string to byte buffers.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
     *
     * @param value fixed length string
     */
    pub fn put_string_lenenc(&mut self, v: &[u8]) {
        let len = v.len();
        if len == 0 {
            self.put_u8(0);
        } else {
            self.put_int_lenenc(len);
            self.put_slice(v);
        }
    }

    /**
     * Read lenenc string from byte buffers for bytes.
     *
     * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
     *
     * @return lenenc bytes
     */
    pub fn get_string_lenenc(&mut self) -> Vec<u8> {
        let length = self.get_int_lenenc() as u32;
        let tmp = self.bytes_mut.split_to(length as usize);
        tmp.to_vec()
    }

    /**
    * Read fixed length string from byte buffers and return bytes.
    *
    * @see <a href="https://dev.mysql.com/doc/internals/en/string.html#packet-Protocol::FixedLengthString">FixedLengthString</a>
    *
    * @param length length of fixed string
    *
    * @return fixed length bytes
    */
    pub fn get_string_fix(&mut self) -> Vec<u8> {
        let length = self.bytes_mut.get_uint(1) as u32 & 0xff;
        let tmp = self.bytes_mut.split_to(length as usize);
        tmp.to_vec()
    }

    pub fn get_remaining_bytes(&mut self) -> Vec<u8> {
        let tmp = self.bytes_mut.bytes();
        tmp.to_vec()
    }
}

impl PacketPayload for MySQLPacketPayload {
    fn get_payload(&mut self) -> Bytes {
        self.bytes_mut.to_bytes()
    }
}

/**
 * Handshake packet protocol for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::Handshake">Handshake</a>
 */
pub trait MySQLPacket {
    /**
     * Get sequence ID.
     *
     * @return sequence ID
     */
    fn get_sequence_id(&self) -> u32;
}

pub struct MySQLHandshakePacket {
    protocol_version: u8,
    server_version: String,
    thread_id: u32,
    capability_flags_lower: u32,
    character_set: u8,
    status_flag: u32,
    seed1: Vec<u8>,
    seed2: Vec<u8>,
    capability_flags_upper: u32,
    auth_plugin_name: String,
}

impl MySQLHandshakePacket {
    pub fn new(thread_id: u32) -> Self {
        let mut seed1: Vec<u8> = Vec::new();
        let mut seed2: Vec<u8> = Vec::new();
        let seed1= generate_random_bytes(8, seed1.as_mut());
        let seed2= generate_random_bytes(12, seed2.as_mut());

        let mut capability_flags_lower: u32 = 0; // capability_flags_lower
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientLongPassword as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientFoundRows as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientLongFlag as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientConnectWithDb as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientOdbc as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientIgnoreSpace as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientProtocol41 as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientInteractive as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientIgnoreSigpipe as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientTransactions as u32;
        capability_flags_lower = capability_flags_lower | MySQLCapabilityFlag::ClientSecureConnection as u32;

        MySQLHandshakePacket {
            protocol_version: PROTOCOL_VERSION,
            server_version: SERVER_VERSION.to_string(),
            thread_id: thread_id,
            capability_flags_lower: capability_flags_lower,
            character_set: CHARSET,
            status_flag: MySQLStatusFlag::ServerStatusAutocommit as u32,
            seed1: seed1,
            seed2: seed2,
            capability_flags_upper: 0,
            auth_plugin_name: "".to_string()
        }
    }
}

impl MySQLPacket for MySQLHandshakePacket {
    fn get_sequence_id(&self) -> u32 {
        0
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLHandshakePacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.protocol_version); // protocol version
        payload.put_string_with_nul(this.server_version.as_bytes()); // server version
        payload.put_u32_le(this.thread_id); //thread id
        payload.put_string_with_nul(this.seed1.as_slice()); //seed 1
        payload.put_u16_le(this.capability_flags_lower as u16); // capability_flags_lower
        payload.put_u8(this.character_set); // charset
        payload.put_u16_le(this.status_flag as u16); // server status
        //capability_flags_upper = capability_flags_upper | (MySQLCapabilityFlag::ClientPluginAuth as u32);
        payload.put_u16_le(this.capability_flags_upper as u16); // capability_flags_upper
        // isClientPluginAuth
        // seed len
        if 0 != ((this.capability_flags_upper << 16) & (MySQLCapabilityFlag::ClientPluginAuth as u32)) {
            payload.put_u8((this.seed1.len() + this.seed2.len()) as u8);
        } else {
            payload.put_u8(0);
        }
        // Write null for reserved to byte buffers.
        let reserved: [u8; 10] = [0,0,0,0,0,0,0,0,0,0];
        payload.put_slice(&reserved);
        // isClientSecureConnection
        // seed 2
        if 0 != (this.capability_flags_lower & (MySQLCapabilityFlag::ClientSecureConnection as u32)) {
            payload.put_string_with_nul(this.seed2.as_slice());
        }
        // isClientPluginAuth
        // auth_plugin_name
        if 0 != ((this.capability_flags_upper << 16) & (MySQLCapabilityFlag::ClientPluginAuth as u32)) {
            payload.put_string_with_nul(this.auth_plugin_name.as_bytes());
        }

        payload
    }
}

/**
 * Handshake response above MySQL 4.1 packet protocol.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/connection-phase-packets.html#packet-Protocol::HandshakeResponse41">HandshakeResponse41</a>
 */

pub struct MySQLHandshakeResponse41Packet {
    sequence_id: u32,
    max_packet_size: u32,
    character_set: u8,
    user_name: String,
    auth_response: Vec<u8>,
    capability_flags: u32,
    database: String,
    auth_plugin_name: String,
}

impl MySQLHandshakeResponse41Packet {
    pub fn new() -> Self {
        MySQLHandshakeResponse41Packet {
            sequence_id: 0,
            max_packet_size: 0,
            character_set: 0,
            user_name: "".to_string(),
            auth_response: vec![],
            capability_flags: 0,
            database: "".to_string(),
            auth_plugin_name: "".to_string()
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLHandshakeResponse41Packet {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        this.capability_flags = payload.get_uint_le(4) as u32;
        this.max_packet_size = payload.get_uint_le(4) as u32;
        this.character_set = payload.get_uint(1) as u8 & 0xff;
        payload.advance(23);

        // string with nul
        this.user_name = payload.get_string_nul();

        this.auth_response = if 0 != (this.capability_flags & MySQLCapabilityFlag::ClientPluginAuthLenencClientData as u32) {
            payload.get_string_lenenc()
        } else if 0 != (this.capability_flags & MySQLCapabilityFlag::ClientSecureConnection as u32) {
            payload.get_string_fix()
        } else {
            let auth = payload.get_string_nul();
            auth.into_bytes()
        };

        this.database = if 0 != (this.capability_flags & MySQLCapabilityFlag::ClientConnectWithDb as u32) {
            payload.get_string_nul()
        } else {
            String::from("")
        };

        this.auth_plugin_name = if 0 != (this.capability_flags & MySQLCapabilityFlag::ClientPluginAuth as u32) {
            payload.get_string_nul()
        } else {
            String::from("")
        };
        this
    }
}

impl MySQLPacket for MySQLHandshakeResponse41Packet {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_QUERY response field count packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html">COM_QUERY field count</a>
 */
pub struct MySQLFieldCountPacket {
    sequence_id: u32,
    column_count: u32,
}

impl MySQLFieldCountPacket {
    pub fn new(sequence_id: u32, column_count: u32) -> Self {
        MySQLFieldCountPacket {
            sequence_id,
            column_count
        }
    }
}

impl MySQLPacket for MySQLFieldCountPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLFieldCountPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_int_lenenc(this.column_count as usize);

        payload
    }
}

/**
 * Column definition above MySQL 4.1 packet protocol.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html#packet-Protocol::ColumnDefinition41">ColumnDefinition41</a>
 * @see <a href="https://mariadb.com/kb/en/library/resultset/#column-definition-packet">Column definition packet</a>
 */
pub struct MySQLColumnDefinition41Packet {
    catalog: String, // "def"
    next_length: u8, // 0x0c
    sequence_id: u32,
    character_set: u16,
    flags: u16,
    schema: String,
    table: String,
    org_table: String,
    name: String,
    org_name: String,
    column_length: u32,
    column_type: u8, // MySQLColumnType
    decimals: u8,
}

impl MySQLColumnDefinition41Packet {
    pub fn new(sequence_id: u32,
               character_set: u16,
               flags: u16,
               schema: String,
               table: String,
               org_table: String,
               name: String,
               org_name: String,
               column_length: u32,
               column_type: u8, // MySQLColumnType
               decimals: u8) -> Self {
        MySQLColumnDefinition41Packet {
            catalog: "def".to_string(),
            next_length: 0x0c,
            sequence_id,
            character_set,
            flags,
            schema,
            table,
            org_table,
            name,
            org_name,
            column_length,
            column_type,
            decimals
        }
    }
}

impl MySQLPacket for MySQLColumnDefinition41Packet {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLColumnDefinition41Packet {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_string_lenenc(this.catalog.as_bytes());
        payload.put_string_lenenc(this.schema.as_bytes());
        payload.put_string_lenenc(this.table.as_bytes());
        payload.put_string_lenenc(this.org_table.as_bytes());
        payload.put_string_lenenc(this.name.as_bytes());
        payload.put_string_lenenc(this.org_name.as_bytes());
        payload.put_int_lenenc(this.next_length as usize);
        payload.put_u16_le(this.character_set);
        payload.put_u32_le(this.column_length);
        payload.put_u8(this.column_type as u8);
        payload.put_u16_le(this.flags);
        payload.put_u8(this.decimals);
        // Write null for reserved to byte buffers.
        let reserved: [u8; 2] = [0,0];
        payload.put_slice(&reserved);

        payload
    }
}

/**
 * Text result set row packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query-response.html#packet-ProtocolText::ResultsetRow">ResultsetRow</a>
 */
pub struct MySQLTextResultSetRowPacket {
    sequence_id: u32,
    data: Vec<(bool, Vec<u8>)>, // NULL = 0xfb
}

impl MySQLTextResultSetRowPacket {
    pub fn new(sequence_id: u32, data: Vec<(bool, Vec<u8>)>) -> Self {
        MySQLTextResultSetRowPacket {
            sequence_id: sequence_id,
            data: data
        }
    }
}

impl MySQLPacket for MySQLTextResultSetRowPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLTextResultSetRowPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq

        for (null, col_v) in this.data.iter() {
            if !*(null) {
                payload.put_u8(0xfb);
            } else {
                payload.put_string_lenenc(col_v.as_slice());
            }
        }

        payload
    }
}

/**
* EOF packet protocol for MySQL.
*
* @see <a href="https://dev.mysql.com/doc/internals/en/packet-EOF_Packet.html">EOF Packet</a>
*/
pub struct MySQLEOFPacket {
    /**
     * Header of EOF packet.
     */
    header: u8, // 0xfe;
    sequence_id: u32,
    warnings: u16,
    status_flags: u16,
}

impl MySQLEOFPacket {
    pub fn new(sequence_id: u32) -> Self {
        MySQLEOFPacket {
            header: 0xfe,
            sequence_id,
            warnings: 0,
            status_flags: MySQLStatusFlag::ServerStatusAutocommit as u16
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLEOFPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.header);
        payload.put_u16_le(this.warnings);
        payload.put_u16_le(this.status_flags);

        payload
    }
}

impl MySQLPacket for MySQLEOFPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * OK packet protocol for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/packet-OK_Packet.html">OK Packet</a>
 */
pub struct MySQLOKPacket {
    /**
     * Header of OK packet.
     */
    header: u8,
    sequence_id: u32,
    affected_rows: u64,
    last_insert_id: u64,
    status_flag: u32,
    warnings: u32,
    info: String,
}

impl MySQLOKPacket {
    pub fn new(sequence_id: u32, affected_rows: u64, last_insert_id: u64) -> Self {
        MySQLOKPacket {
            header: 0x00,
            sequence_id: sequence_id,
            affected_rows: affected_rows,
            last_insert_id: last_insert_id,
            status_flag: MySQLStatusFlag::ServerStatusAutocommit as u32,
            warnings: 0,
            info: "".to_string()
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLOKPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.header);

        payload.put_int_lenenc(this.affected_rows as usize);
        payload.put_int_lenenc(this.last_insert_id as usize);

        payload.put_u16_le(this.status_flag as u16);
        payload.put_u16_le(this.warnings as u16);

        payload.put_slice(this.info.as_bytes());

        payload
    }
}

impl MySQLPacket for MySQLOKPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_QUERY command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-query.html">COM_QUERY</a>
 */
pub struct MySQLComQueryPacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    sql: Vec<u8>
}

impl MySQLComQueryPacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComQueryPacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            sql: vec![]
        }
    }

    pub fn get_sql(&self) -> Vec<u8> {
        self.sql.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComQueryPacket {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        let bytes = payload.get_remaining_bytes();
        this.sql = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComQueryPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_INIT_DB command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-init-db.html#packet-COM_INIT_DB">COM_INIT_DB</a>
 */
pub struct MySQLComInitDbPacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    schema: Vec<u8>
}

impl MySQLComInitDbPacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComInitDbPacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            schema: vec![]
        }
    }

    pub fn get_schema(&self) -> Vec<u8> {
        self.schema.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComInitDbPacket {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        let bytes = payload.get_remaining_bytes();
        this.schema = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComInitDbPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_FIELD_LIST command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-field-list.html">COM_FIELD_LIST</a>
 */
pub struct MySQLComFieldListPacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    table: Vec<u8>,
    field_wildcard: Vec<u8>
}

impl MySQLComFieldListPacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComFieldListPacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            table: vec![],
            field_wildcard: vec![]
        }
    }

    pub fn get_table(&self) -> Vec<u8> {
        self.table.clone()
    }

    pub fn get_field_wildcard(&self) -> Vec<u8> {
        self.field_wildcard.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComFieldListPacket {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        this.table = payload.get_string_nul().into_bytes();
        let bytes = payload.get_remaining_bytes();
        this.field_wildcard = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComFieldListPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_STMT_PREPARE command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-stmt-prepare.html">COM_STMT_PREPARE</a>
 */
pub struct MySQLComStmtPreparePacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    sql: Vec<u8>,
}

impl MySQLComStmtPreparePacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComStmtPreparePacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            sql: vec![],
        }
    }

    pub fn get_sql(&self) -> Vec<u8> {
        self.sql.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComStmtPreparePacket {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        let bytes = payload.get_remaining_bytes();
        this.sql = Vec::from(bytes.as_slice());
        this
    }
}

impl MySQLPacket for MySQLComStmtPreparePacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_STMT_PREPARE_OK packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-stmt-prepare-response.html#packet-COM_STMT_PREPARE_OK">COM_STMT_PREPARE_OK</a>
 */
pub struct MySQLComStmtPrepareOKPacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    status: u8,
    statement_id: u32,
    columns_count: u16,
    parameters_count: u16,
    warning_count: u16,
}

impl MySQLComStmtPrepareOKPacket {
    pub fn new(sequence_id: u32,
               command_type: u8, // MySQLCommandPacketType,
               statement_id: u32,
               columns_count: u16,
               parameters_count: u16,
               warning_count: u16) -> Self {
        MySQLComStmtPrepareOKPacket {
            sequence_id,
            command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            status: 0x00,
            statement_id,
            columns_count,
            parameters_count,
            warning_count,
        }
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComStmtPrepareOKPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(this.status);
        payload.put_u32_le(this.statement_id);
        payload.put_u16_le(this.columns_count);
        payload.put_u16_le(this.parameters_count);
        let reserved: [u8; 1] = [0];
        payload.put_slice(&reserved);
        payload.put_u16_le(this.warning_count);
        payload
    }
}

impl MySQLPacket for MySQLComStmtPrepareOKPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * COM_STMT_EXECUTE command packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/com-stmt-execute.html">COM_STMT_EXECUTE</a>
 */
pub struct MySQLComStmtExecutePacket {
    sequence_id: u32,
    command_type: u8, // MySQLCommandPacketType,
    statement_id: u32,
    flags: u16,
    null_bit_map: Vec<u8>,
    new_parameters_bound_flag: u8,
    iteration_count: u8,
    sql: Vec<u8>,
    parameters: Vec<PrepareParamValue>
}

impl MySQLComStmtExecutePacket {
    pub fn new(command_type: u8) -> Self {
        MySQLComStmtExecutePacket {
            sequence_id: 0,
            command_type: command_type, // MySQLCommandPacketType::value_of(command_type & 0xff),
            statement_id: 0,
            flags: 0,
            null_bit_map: vec![],
            new_parameters_bound_flag: 0,
            iteration_count: 0,
            sql: vec![],
            parameters: vec![]
        }
    }

    pub fn get_sql(&self) -> Vec<u8> {
        self.sql.clone()
    }

    pub fn get_command_type(&self) -> u8 {
        self.command_type
    }

    pub fn get_parameters(&self) -> Vec<PrepareParamValue> {
        self.parameters.clone()
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLComStmtExecutePacket {
    fn decode<'p,'d>(this: &'d mut Self, header: &'p MySQLPacketHeader, payload: &'p mut MySQLPacketPayload) -> &'d mut Self {
        this.statement_id = payload.get_uint_le(4) as u32;
        this.flags = payload.get_uint_le(1) as u16;
        this.iteration_count = payload.get_uint_le(1) as u8;
        assert_eq!(1, this.iteration_count);
        let session_id = header.get_session_id();
        let parameters_count = get_session_prepare_stmt_context_parameters_count(this.statement_id as u64);
        ///
        /// Null bitmap for MySQL.
        ///
        /// @see <a href="https://dev.mysql.com/doc/internals/en/null-bitmap.html">NULL-Bitmap</a>
        ///
        let mut null_bit_map: Vec<u8> = vec![];
        let offset = 0;
        let num_params = parameters_count as usize;
        if num_params > 0 {
            let len = (num_params + offset + 7) / 8;
            null_bit_map = Vec::with_capacity(len);
            for i in 0..len {
                null_bit_map[i] = payload.get_uint(1) as u8 & 0xff;
            }
            let new_parameters_bound_flag = payload.get_uint(1) as u8 & 0xff;
            let mut parameter_types = Vec::with_capacity(num_params);
            if MySQLNewParametersBoundFlag::ParameterTypeExist as u8 == new_parameters_bound_flag {
                for _ in 0..num_params {
                    let column_type = payload.get_uint(1) as u8 & 0xff;
                    let unsigned_flag = payload.get_uint(1) as u8 & 0xff;
                    parameter_types.push((column_type, unsigned_flag));
                }
                set_session_prepare_stmt_context_parameter_types( this.statement_id as u64, parameter_types.clone());
            }
            this.parameters = Vec::with_capacity(num_params);
            for i in 0..num_params {
                let null_byte_position = (i + offset) / 8;
                let null_bit_position = (i + offset) % 8;
                if (null_bit_map[null_byte_position] & (1 << null_bit_position) as u8) != 0 {
                    this.parameters.push(PrepareParamValue::NULL);
                } else {
                    let (column_type, unsigned_flag) = parameter_types.get(i).unwrap();
                    let column_flags = MySQLColumnFlags::from_bits_truncate(*unsigned_flag as u16);
                    let param_value = binary::read_bin(payload, MySQLColumnType::from(*column_type), column_flags.contains(MySQLColumnFlags::UNSIGNED_FLAG)).unwrap();
                    this.parameters.push(param_value);
                }
            }
        }
        this
    }
}

impl MySQLPacket for MySQLComStmtExecutePacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

/**
 * Binary result set row packet for MySQL.
 *
 * @see <a href="https://dev.mysql.com/doc/internals/en/binary-protocol-resultset-row.html">Binary Protocol ResultSet Row</a>
 */
pub struct MySQLBinaryResultSetRowPacket {
    sequence_id: u32,
    data: Vec<PrepareParamValue>,
}

impl MySQLBinaryResultSetRowPacket {
    pub fn new(sequence_id: u32, data: Vec<PrepareParamValue>) -> Self {
        MySQLBinaryResultSetRowPacket {
            sequence_id: sequence_id,
            data: data
        }
    }
}

impl MySQLPacket for MySQLBinaryResultSetRowPacket {
    fn get_sequence_id(&self) -> u32 {
        self.sequence_id
    }
}

impl DatabasePacket<MySQLPacketHeader, MySQLPacketPayload> for MySQLBinaryResultSetRowPacket {
    fn encode<'p,'d>(this: &'d mut Self, payload: &'p mut MySQLPacketPayload) -> &'p mut MySQLPacketPayload {
        payload.put_u8(this.get_sequence_id() as u8); // seq
        payload.put_u8(0x00); // PACKET_HEADER

        let null_bitmap_offset = 2;
        let columns_numbers = this.data.len();
        let len = (columns_numbers + null_bitmap_offset + 7) / 8;
        let mut null_bit_map: Vec<u8> = Vec::with_capacity(len);
        for i in 0..len {
            null_bit_map[i] = 0u8;
            if let Some(v) = this.data.get(i) {
                if *v == PrepareParamValue::NULL {
                    let null_byte_position = (i + null_bitmap_offset) / 8;
                    let null_bit_position = (i + null_bitmap_offset) % 8;
                    null_bit_map[null_byte_position] = (1 << null_bit_position) as u8;
                }
            }
        }

        for v in null_bit_map.iter() {
            payload.put_u8(*v);
        }

        for v in this.data.iter() {
            binary::write_bin(v, payload);
        }

        payload
    }
}